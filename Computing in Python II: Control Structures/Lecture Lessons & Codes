
Indentation: Spaces at the beginning of a line that are used to group together blocks of code. All consecutive lines of code at the same level of indentation are in a single code block.

Scope: The portion of a program’s execution during which a variable can be seen and accessed.

Scope can work pretty differently from language to language, so when you start to learn another programming language, be prepared to investigate how scope works in the new language. Generally, it works very differently between scripting languages (like Python) and compiled languages (like Java).

Scope in Python is actually a little bit more straightforward to understand than in many languages, but it also carries its own challenges. Generally, every variable or function we create has a line on which it is created. If that line has already run, then the scope for that variable or function has begun. If it hasn't, then that variable's or function's scope has not yet begun.

Note that a variable's scope begins with the line on which it's created, but that means it cannot be used until the next line. For example, we could not run this line of code unless a_num had already been created:
a_num = a_num + 1

Typically we describe the scope of a variable as starting on the line on which it's created, but be careful that you're not trying to create and use the variable on the same line: its scope doesn't start until the line has finished running.

---------------------------------------------------------------------------------------------------------------------------------

As we've mentioned before, Python's notion of scope is different from many other languages. In Java, for example, if you define a variable inside a conditional, then the variable ceases to exist when the condition is done. In Python, however the variable continues to exist.

---------------------------------------------------------------------------------------------------------------------------------------

For this next problem, it will be helpful to know about Python's ordinal function.

Every character has a number associated with it in ASCII. A capital "A" is 65. A capital "B" is 66. A lower-case "z" is 122. A percent sign "%" is 37.

You can find the number associated with a character using the ord() function. For example, ord("A") will return 65. ord("Z") will return 90.

You can use this to find the number of characters between two letters. For example, ord("R") - ord("D") is 14, meaning there are 14 letters between D and R.

Capital letters are numbered 65 through 90. Lower-case letters are numbered 97 through 122. Numerals are numbered 48 through 57. Reserved system characters are numbered 0 through 31, while the remaining numbers below 127 (32 to 47; 58 to 64; 91 to 96; and 123 to 128) are punctuation marks.

https://www.asciitable.com/
-------------------------------------------------------------------------------------------------------------------

Loop Control Variable: A variable whose value is the number of times a loop has run. It is used to check if the loop should keep running (e.g. if it has run as many times as it’s supposed to).
range(begin, end): Takes as input two variables, a first number and a last number, and provides the list of numbers for a for loop to iterate over.

For-Each Loop: A loop control structure that runs a block of code a predetermined number of times, where the number of times comes from the length of some list and the items in the list are automatically loaded into a variable for usage in the block of code.

Iterate: To repeat code a number of times. For example, if a loop runs for each item in a list, the loop “iterates” over the list. Each time the code is repeated is a single iteration.

random.randint(min, max): Returns a random integer greater than or equal to min and less than or equal to max.
-----------------------------------------------------------------------------------------------------------------------------------------

The three advanced loop keywords we'll cover are:

    continue: Skip the rest of the current iteration of the loop and continue with the next iteration of the loop (if there is a next iteration).
    break: Skip the rest of the current iteration of the loop and break out of the loop altogether, skipping any later iterations, too.
    pass: Designate an 'empty' body for a control structure.
    
The pass keyword is a "no-operation" keyword. It does exactly nothing. It's often used as a placeholder for code which will be added later:

if response == "yes":
    pass  # add "yes" code later.

pass : Break the requirement that control structures must have code within them and skip the body of the control structure 
----------------------------------------------------------------------------------------------------------------------------------------
It follows this template:

string[start: end: step]

Where,

start: The starting index of the substring. The character at this index is included in the substring. If start is not included, it is assumed to equal to 0.

end: The terminating index of the substring. The character at this index is NOT included in the substring. If end is not included, or if the specified value exceeds the string length, it is assumed to be equal to the length of the string by default.

step: Every ‘step’ character after the current character to be included. The default value is 1. If the step value is omitted, it is assumed to equal to 1.
Template

string[start:end]: Get all characters from index start to end-1

string[:end]: Get all characters from the beginning of the string to end-1

string[start:]: Get all characters from index start to the end of the string

string[start:end:step]: Get all characters from start to end-1 discounting every step character
---------------------------------------------------------------------------------------------------------------

Global Variables

Variables that are created outside of a function (as in all of the examples above) are known as global variables.

Global variables can be used by everyone, both inside of functions and outside.


The global Keyword

Normally, when you create a variable inside a function, that variable is local, and can only be used inside that function.

To create a global variable inside a function, you can use the global keyword.
-------------------------------------------------------------------------------------------------------------------------

The two common errors we'll encounter with functions are:

    Parameter Mismatch: We gave a function more or fewer parameters than it expected.
    Scope Error: We tried to use a variable in a function that was created outside the function, or similarly, we tried to use a variable outside a function that was created inside the function.

------------------------------------------------------------------------------------------------------------------------------------

Where Does None Come From?

Although it can be confusing in practice, the principle of None and functions is relatively simple: if a function does not otherwise return anything, it returns None.

In your mind, you can imagine adding return None as the last line in any function. If no other return statement has already been run, then return None is run and None is returned. Remember, though, running a return statement terminates the function: as soon as one runs, the entire function ends no matter what.
From Simple to Complex

So when does the function return None? Whenever it ends without returning anything else. In the problem above, notice that result is None whenever the function does not otherwise return something (1, 3), deliberately returns None before returning anything else (5, 7), or returns a different function that itself returns None (8).

For little functions like these, it's usually easy to avoid this issue: after all, you can just check the last line of the function to see if there's a return statement.  Where it becomes difficult is when you start using return statements along with some more complex control structures.

For example, take a look at this function:
def some_function(number):
    if number > 0:
        return "Positive!"
    elif number < 0:
        return "Negative!"

What happens if we call some_function(0)? The first conditional is false because 0 is not greater than 0. The second conditional is false because 0 is not less than 0. Then, the function is over: so, it returns None.

This is where debugging these issues becomes difficult: it's not that these functions always return None like the ones in the exercise above, but rather they sometimes return None depending on the input.
