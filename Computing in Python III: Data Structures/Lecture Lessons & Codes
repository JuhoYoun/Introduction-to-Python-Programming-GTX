Data Structures: Approaches to organizing abstract data types, such that the data can be accessed efficiently.

"Under the hood", everything in computing boils down to 1s and 0s. So, everything is built out of the absolute most basic data types imaginable! The complex behavior we see from the computers we use every day comes because computers know how to interpret 1s and 0s in different ways. A certain combination of 1s and 0s can be interpreted as the letter A or the number 7.

Working with the 1s and 0s directly is extremely difficult, so that's why you and I instead build on a layer that goes ahead and takes care of interpreting 1s and 0s as more complex types. However, dealing with just letters and numbers is still really difficult if we're building complex applications, so in this unit, we'll discuss how we can build and use more complex data types. These data types are still just letters and numbers, but they're organized and accessed in ways that make programming easier.

List-Like Structures: Also referred to as sequences and collections, a data structure that holds multiple individual values gathered together under one variable name, accessed via indices. This includes structures like lists, arrays, and tuples. Lists are simultaneously a general type of data structure and a specific data type in some languages.

Index: A number used to access a particular element from a list-like data structure. Traditionally, most programming languages assign the first item of a list-like data structure the index 0.

String: A data structure that holds a list, or a string, of characters.

Lists: A data structure that holds multiple individual values gathered together under one variable name, accessed via indices. Similar to arrays and tuples.

File Input and Output: The complementary processes of saving data to a file and loading data from a file, generally such that the state of the memory of the program is the same after saving and loading have occurred.

Dictionaries: A data structure comprised of key-value pairs, where a key is entered into the dictionary to get out a value. Similar to or synonymous with Maps, Associative Arrays, HashMaps, and Hashtables.

Passing by Value vs. Passing by Reference

Passing by Value
An approach for passing arguments into a function where the function is not able to modify the variable whose value was getting passed, only its local parameter that accepts the argument.

Passing by Reference
An approach for passing arguments into a function where the function is able to modify the variable whose value was getting passed, changing it for both the function and the code that called the function.

Reference
An alias to a variable that already exists. Either the reference or the variable name can be used to access the value stored in that variable.

That cryptic identifier is called a reference (or a memory address). It tells you where the variable itself can actually be found. When we pass by value, we grab the variable name (File A), 
find its reference (E1559), use the reference to find the value (5), and then tell the function the value (“Hey Addison, 5 and...”). The function never knows where the value came from.
When we pass by reference, we grab the variable name (File A), find its refer- ence (E1559), and pass that reference directly to the function (“Hey Addison, the value stored at E1559 and...”). 
The function then looks up the value on its own, but because it knows the reference, it can change the value if it wants to. It doesn’t have to, but it can.

---------------------------------------------------------------------------------------------------------------------------------------------
Passing by Value and Reference in Python

Python deals with passing-by-value and passing-by-reference a little strangely. In reality, everything is passed by reference, but because of some details we'll cover next lesson, it often appears to be passing by value.

integer
ex)
def addOne(integer):
    integer = integer + 1
    print("integer ", integer)
i = 1
print("Before adding one ", i)
addOne(i)
print("After adding one ", i)

-> seems Pass by value

string
ex)
def addC(astring):
    astring = astring + "!"
    print("string ", astring)
s = "abc"
print("Before adding ", i)
addC(s)
print("After adding ", i)

-> seems Pass by value
  
list
ex)
def addmore(alist):
    alist.append("Teddy")
    print(alist)
l = ["Angie", "Jake"]
print("Before adding ", l)
addmore(l)
print("After adding ", l)

-> seems Pass by reference this time!

Really?
This means that Python seems to pass primitive data types such as integers and strings by value, and advanced data types such as lists by reference, 
right? Practi- cally speaking, yes. Accurately speaking, no! The ultimate effect is that it’s as if Python is passing these primitive data types by value, 
but in reality, something dif- ferent is going on: Python has immutable data types. That gets tricky, though, so we’ll talk about that next lesson. 
For now, it’s sufficient to know: there are some data types that Python effectively passes “by value”, but for the majority of data types, Python passes by reference.

--------------------------------------------------------------------------------------------------------------------------------------------------------
We'll cover strings next chapter, and lists after that. It's worth noting here, though, that one of the most common mistakes when working with strings comes from this concept. For example, strings have a method called upper() that returns an uppercase version of the string. For example:
1| my_string = "David"
2| print(my_string.upper())

Notice we're using dot notation here -- upper() is a method that acts on my_string. We'll talk about this more in a couple lessons.

The code above will print "DAVID", the upper case version of the value of my_string. However, this code...
1| my_string = "David"
2| my_string.upper()
3| print(my_string)

...prints "David". my_string.upper() doesn't change the value of my_string -- it just returns the value that results from making a certain change. It tells you what the uppercase version of myString would be, but it doesn't actually change myString to its uppercase version. To do that, we would have to do this:
1| my_string = "David"
2| my_string = my_string.upper()
3| print(my_string)

Line 2 here sets the value of my_string equal to what it would be if it was uppercase, effectively making the conversion.
------------------------------------------------------------------------------------------------------------------------------

Variable Assignments

integer
ex)
int_a = 1
int_b = int_a + 1
int_a = 3
print(int_a, int_b)

-> seems assignment by value

list
ex)
list_a = ['a', 'b']
list_b = list_a
list_a.append('c')
print(list_a)
print(list_b)

-> seems assignment by reference
-> list_b is set equal to reference to list_a
-> list_a and list_b are pointing to the same data

You might notice something in these examples: generally, if we modify a variable's value using a method (like my_list.append("An Item")), 
then usually it mirrors the "assignment by reference" idea. If we modify a variable's value using an operator (like my_int += 1 or my_string = my_string + "1"), 
then it mirrors the "assignment by value" idea. That's because operators usually only work on more "primitive" data types, 
and more "primitive" data types are usually assigned or passed "by value".
-------------------------------------------------------------------------------------------------

Mutability in Python

Immutable Data Types : integer, float, boolean, string, tuple, frozen set, byte

Mutable Data Types : list, set, dictionary, byte array

mutable : a value can change after the value is allocated on a memory spot
immutable : a value can not change once the value is allocated on a memory spot


All variables in Python are passed by reference. However, we saw some appear to act as if they're passed by value. The reason they acted this way is because they were immutable. 
Keep watching and we'll explore that more.

immutable data type

ex)
int_a = 1
int_b = int_a
print(int_a, int_b) # 1 1
print(id(int_a), id(int_b)) # int_a and int_b point to same memory spot -> pass by reference
int_b = int_b + 1
print(int_a, int_b) # 1 2
print(id(int_a), id(int_b)) # int_a still points to the same memory spot but int_b points to differenct memory spot 
-> This is because integer is immutable data type -> On this line, the code reassign a value (2) to int_b howerver the memory spot where int_b points cannot store 
different value because 1 is already stored in that memory spot and integer is not immutable so the value 1 cannot be changed to 2 -> so ptyhon just allocate another memory spot to 
store integer 2 and let int_b points to the new memory spot

ex)
def addOne(anInteger): 
    print(anInteger) # 1
    print(id(anInteger)) # same address as someInteger -> a local variable anInteger is creadted and points to the same memory spot as someInteger -> pass by reference
    anInteger = anInteger + 1 # python allocate different memory spot and store 2 and let anInteger points to the memory spot
    print(anInteger) # 2
    print(id(anInteger)) # shows changed address

someInteger = 1
print(id(someInteger))
addOne(someInteger)
print(someInteger) #1


mutable data type

ex)
list_a = ['a', 'b', 'c']
list_b = list_a
print(id(list_a), id(list)b)) # list_a and list_b point to same memory spot
list_b.append('d') #add d in list_b
print(list_a, list_b) # d is also added in list_a -> list_a and list_b point same list and the list is changed then both list_a and list_b are changed
print(id(list_a), id(list_b)) # list_a and list_b still point to the same memory spot

-> append() method is not reassining append() actually change the value stored in a memory spot

ex)
def addCharacter(aList):
    print(id(aList)) # same address as someList
    aList.append('d') #d is added to aList
    print(aList) 
    print(id(aList)) # address not changed
    
someList = ['a', 'b', 'c']
print(id(someList))
addCharacter(someList)
print(someList) # d is added to someList
print(id(someList)) # address not changed

ex)
list_a = ['a', 'b', 'c']
list_b = list_a
print(list_a, list_b) # list_a and list_b point to the same memory spot therefore print the same list
print(id(list_a), id(list_b)) # both point to same address 
list_a = ['a', 'b', 'c', 'd'] # reasign a value to list_a -> this time the value in the memory spot does not change but python allocate a new memory spot and store new list in that memory and let list_a point to the memory!
print(list_a, list_b) # list_b still point the first memory spot so only has a b c but list_a points to different memory spot and print a b c d
print(id(list_a), id(list_b)) # of course they have different addresses

-> reassigning is different from append() method -> append() method modify the value in a memory but reassigning just create a new memory spot


More things to know.....

a = 1
b = 1
print(id(a), id(b)) # same address they have! 

list_a = ['a']
list_b = ['a']
print(id(list_a), id(list_b)) # different address!

-> separately assigned to the value 1; yet, because Python creates 1 in memory, it simply assigns both variables to point at the same spot. This only works because integers are immutable:
-> Mutable variables will behave differently, the two lists are assigned the same value. Because they are mutable, though, Python creates that value twice in memory.

----------------------------------------------------------------------------------------------------------------------------------

String: A data structure that holds a list, or a string, of characters.

Character: A single letter, number, symbol, or special character.

Unicode: A computing industry standard that sets what hexadecimal codes correspond to what characters, so that text appears consistent across platforms.

Hexadecimal: A short-hand expression of the ones and zeroes that comprise computer data, comprised of 16 characters, 0 through 9 and A through F.

Newline Character: A Unicode character, either LF (line feed) or CR (carriage return), that is rendered as the beginning of a new line of text.

A line feed means moving one line forward. The code is \n.
A carriage return means moving the cursor to the beginning of the line. The code is \r.

Windows editors often still use the combination of both as \r\n in text files. Unix uses mostly only the \n.

Have you ever created a plain text file on Mac OS or Unix and then opened it on Windows, only to find everything was on one line? 
That’s because Mac OS uses the line feed character to represent its new line, while Windows uses both carriage returns and line feeds. 
When Windows sees just line feeds, it doesn’t render them the same way.

------------------------------------------------------------------------------------------------------------------------------------

Escape Sequence
A sequence of characters that, when occurring in a string, is interpreted to have a meaning beyond the characters themselves. The most common example is “\n”, which is interpreted by many languages as representing a newline character.

• \n, which inserts a new line.
• \t, which inserts a tab.
• \", which inserts a quotation mark without terminating the string (another way
to include quotation marks and apostrophes inside strings).
• \\, which inserts a forward slash without interpreting it as an escape character (note that otherwise, the \n at the end of the string would have been a new line).

String Concatenation
The process of putting two or more strings together in order
to form one string made of the individual strings. For example, concatenating “A” with “B” would give “AB”.

ex)
myString1 = "12345"
myString2 = "67890"
myString3 = myString1 + myString2
print("Assignment Concatenation: " + myString3)
print("In-Line Concatenation: " + myString1 + myString2)
myString1 += myString2
print("Self-Assignment Concatenation: " + myString1)


String Slicing: The Python term for obtaining substrings from within a string based on character indices.

Zero-Indexing: A convention in most programming languages where the first item of a list of items is considered the “0th” item, not the 1st item.

Why zero-indexing? This goes all the way back to the early days of computing. Remember, a variable points to a place in memory where the value is stored. 
Early on, lists were technically just consecutive locations in memory. The index told the list how many places in memory to skip. To get the first item in a list, 
you wouldn’t skip any places in memory, so your index would be 0.


    "Hello, world!"[1:9] → This gives "ello, wo". The slice starts at the character with index 1, and goes until (but not including) the character with index 9, and includes every character in that range.
    "Hello, world!"[1:9:2] → This gives "el,w". Like above, it starts with the character at index 1, and goes until (but not including) the character with index 9. Here, though, it includes every other character. The :2 at the end forces it to only take characters 1, 3, 5, and 7.
    "Hello, world!" [::3] → This gives "Hl r!". Leaving the first two spots blank tells it to look at the entire string, but putting :3 at the end says to only take every third character. It does so starting at the beginning, and takes the characters at indices 0, 3, 6, 9, and 12 (H, l, space, r, and !).

In Operator

The in operator is unique; it seems to take on different meanings when used in a for loop (e.g., for i in range(0, 3):) and in a conditional (if “Bob” in myList:).
The in operator can be used with strings to check if a substring is part of a string

find method

find(text, [start], [end]): A method of the string data type that will find the first instance of the value of text within the string calling the method. Optionally, 
also takes parameters start and end to mark where to search in the string (index). Returns -1 if text cannot be found.
